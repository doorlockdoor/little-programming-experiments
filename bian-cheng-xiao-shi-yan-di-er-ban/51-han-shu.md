# 5-1、函数

在写前面的练习题时，代码功能一多，代码行数一多，好像又显得有些“拥挤”了。

这一次的问题不再是指代，而是代码本身的功能越来越复杂了。仔细观察上一次的练习题，可以发现我们没有划分代码之间的功能，所有的过程无论前后，都挤在了一起，离远了看根本不知道哪一部分代码是用来干什么的。

而这就需要我们拥有一个新的能力，即把过程分离成一个个的模块。

这就是**函数**：

* 如果说，**变量是把一个数据与一个名称绑定**。
* 那么，**函数就是把一堆过程与一个名称绑定**。并提供了输入和输出。

和上一章的多行书写代码，我们使用了赋值这个抽象功能一样，函数也是一种抽象功能，将原本挤在一起的代码解耦，分为多个部分。

我们可以总结成，函数是对“过程”的抽象，例如：

```python
# 定义函数
def get_area(r):
    pi = 3.14
    area = pi * r * r
    return area

def get_price(hkd):
    return hkd * 0.92

# 使用函数
area = get_area(0.1)
cny = get_price(area * 2340)
print(cny)
```

<figure><img src="../.gitbook/assets/图片-20240422210643-mrxqicc.png" alt="" width="375"><figcaption></figcaption></figure>

语法规则为：

```python
# 定义函数
def 函数名(形参):
    过程
    return 返回结果

# 使用函数，其实就是我们前面提到的调用表达式
函数名(实参)
```

函数的书写分为**定义**和**使用**两个步骤：

* **定义**是用def关键字（在其他编程语言中也可能是fn、func、function等关键字）来向编译器声明我们需要将一个过程与一个名称进行绑定。
* 在绑定的过程中，我们需要写下函数名、参数（可以有很多个）、过程、返回结果。
* 之后便是**使用**调用表达式，来调用函数。

像前面例子中用到的max和min等内置函数，它们的def定义就写在官方内置模块中，程序运行后可以自动使用，不需要我们再重复定义一遍。而我们自己的函数（函数定义）则放在自己的代码中，相当于我们的本地代码库。而如果想要引用别人写好的函数（功能），还可以导入官方库或第三方库，在导入库之后，我们就可以随意使用别人写好的函数功能了，这在后文的条件语句章节有实际案例。

***

**下面我们来讲一下函数定义里面具体怎么写：**

{% code overflow="wrap" %}
```python
# 定义函数
def 函数名(形参):
    过程
    return 返回结果
```
{% endcode %}

定义时的形参（形式参数），区别于使用时的实参（实际参数）。

之所以会有这样的区别，是因为在定义函数时，我们并不知道外面的使用者会如何取变量名称，例如随便举一个例子`def get_hp(character)`，假设这是获取角色血量的函数。

在外面使用时例如我们写`get_hp(character_1)`，`get_hp(character_2)`，这里的`character_1`和`character_2`就是实际参数。而无论外面使用什么名称，在函数里面都统一叫做本地名，即`character`，这就是形式参数，它只有在外面真正传递参数进来时，才会“复苏”，并指向对应的数据。

而这就又要引入一个新的概念，**作用域**。

我们可以观察到，在定义函数时，python会有缩进（在其他语言中一般是{}花括号），例如：

{% code overflow="wrap" %}
```python
# 定义函数，接收一个参数，名为character
def get_hp(character):
    hp = character.hp
    print(hp)

# 使用函数
get_hp(zhang_san)    # 输入zhang_san，张三
get_hp(li_si)        # 输入li_si，李四
```
{% endcode %}

这里的缩进即进入了一个局部作用域，里面的变量被称为局部变量，包括形参在内的所有数据，都是“暂时的”，它们会在离开作用域后自动释放（消失）。

而最外层的代码则是全局作用域，变量也被称为全局变量，会一直存在。

> 这也是一个区分实际参数和形式参数的原因，因为形参会在函数结束后释放，而外部的实参则会维持原状，直到它自己也结束了它的作用域。

**这样设计的初衷是形成一个个的代码执行环境，每一个局部环境拥有自己的局部变量，也可以访问外部的变量，然后在执行完成后，释放自己所占用的内存**。在后面的章节《递归》中，大家将会了解到这样一个局部环境的重要性，因为没有它们，就没有递归的执行。

但一般情况下我们都是无法主动缩进（作用域）的，为了防止滥用，只有特殊的语句才会有局部环境。

例如函数的定义，又例如之后会介绍的if语句和for语句等等。

***

**下面我们继续介绍函数：**

由于函数在计算完成后会自动释放，所以我们必须把结果值给return回去（如果需要的话），将其传递给调用函数的外部使用者，例如：

{% code overflow="wrap" %}
```python
# 定义函数，接收一个参数，名为character
def get_hp(character):
    hp = character.hp
    return hp

# 使用函数，并用变量名接收返回值（如果有的话）
hp_1 = get_hp(zhang_san)    # 输入zhang_san，张三
hp_2 = get_hp(li_si)        # 输入li_si，李四
print(hp_1)
print(hp_2)
```
{% endcode %}

然后我们介绍一下函数定义的一些额外细节。

在写法上，函数也可以没有参数，例如：

{% code overflow="wrap" %}
```python
def get_today():
    return 今天的日期
```
{% endcode %}

或没有返回值（没有return），例如：

{% code overflow="wrap" %}
```python
def new_print(content, end):
    print(content + end)
```
{% endcode %}

或既没有参数也没有返回值，例如：

{% code overflow="wrap" %}
```python
def stop():
    程序停机
```
{% endcode %}

而和前面的所有功能一样，函数内部也可以嵌套表达式和语句，同时return语句也可以简写。

例如：

```python
def get_today():
    return "2024/4/1"

# 接收函数的返回值，绑定到一个名称上，最后打印日期
today = get_today()
print(today)
```

需要注意的是，即便使用函数时没有参数，它也必须带上()圆括号，表示这是一个函数的调用表达式，所有的函数语句，函数名+圆括号都是不能省略的。

例如：

```python
def print_today():
    today = "2024/4/1"
    print(today)

# 没有返回值和参数，直接触发函数
print_today()
```

<figure><img src="../.gitbook/assets/屏幕截图 2024-04-23 154235.png" alt="" width="375"><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/屏幕截图 2024-04-23 154344.png" alt="" width="375"><figcaption></figcaption></figure>

> 为什么函数名必须加上圆括号？一个简单的理由是区分变量名和函数名，函数名的本质只是一个名称+绑定数据，而变量名的本质也是如此，两者不存在根本上的差异。事实上，在高阶运用中，我们可以直接在变量名后面加上圆括号把它当成函数使用；也可以把函数名没有圆括号，当成变量名传递。即函数是一等公民（first class），它和变量是等价的，两者不会区分对待，因此更本质的差异其实是数据的类型，以及()圆括号本身，=赋值符号本身，它们才是魔法的来源。

**5-1、练习题**

题目1：

{% code overflow="wrap" %}
```python
# 现在我们再来实现一遍这个例子，加入函数这个新功能，把各个代码划分清晰：
# 我们有4颗树，高度分别为2.5，8.53，9.01，14.15，我们需要在最高的树和最低的树之间（高度差），按照1.5的间隔放置圣诞树灯。每个球形灯泡的价格与其横截面面积有关，假设该灯泡半径为0.1，每1单位的横截面积的价格与一台港版任天堂ns主机的2340港元相当。请计算出我们一共需要几个灯泡，每个灯泡多少人民币，一共需要几人民币。
```
{% endcode %}

